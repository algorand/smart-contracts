{"ast":null,"code":"import _has from \"lodash-es/has\";\nimport _keys from \"lodash-es/keys\";\nimport _forEach from \"lodash-es/forEach\";\nimport _filter from \"lodash-es/filter\";\nimport _keyBy from \"lodash-es/keyBy\";\nimport { Children, isValidElement } from 'react';\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {object} children Element's children\n * @return {object} Mapping of key to child\n */\n\nexport var getChildMapping = function getChildMapping(children) {\n  return _keyBy(_filter(Children.toArray(children), isValidElement), 'key');\n};\n\nvar getPendingKeys = function getPendingKeys(prev, next) {\n  var nextKeysPending = {};\n  var pendingKeys = [];\n\n  _forEach(_keys(prev), function (prevKey) {\n    if (!_has(next, prevKey)) {\n      pendingKeys.push(prevKey);\n      return;\n    }\n\n    if (pendingKeys.length) {\n      nextKeysPending[prevKey] = pendingKeys;\n      pendingKeys = [];\n    }\n  });\n\n  return [nextKeysPending, pendingKeys];\n};\n\nvar getValue = function getValue(key, prev, next) {\n  return _has(next, key) ? next[key] : prev[key];\n};\n/**\n * When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*\n * since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set\n * of keys and merges them with its best guess of the correct ordering.\n *\n * @param {object} prev Prev children as returned from `getChildMapping()`\n * @param {object} next Next children as returned from `getChildMapping()`\n * @return {object} A key set that contains all keys in `prev` and all keys in `next` in a reasonable order\n */\n\n\nexport var mergeChildMappings = function mergeChildMappings(prev, next) {\n  if (prev === void 0) {\n    prev = {};\n  }\n\n  if (next === void 0) {\n    next = {};\n  }\n\n  var childMapping = {};\n\n  var _getPendingKeys = getPendingKeys(prev, next),\n      nextKeysPending = _getPendingKeys[0],\n      pendingKeys = _getPendingKeys[1];\n\n  _forEach(_keys(next), function (nextKey) {\n    if (_has(nextKeysPending, nextKey)) {\n      _forEach(nextKeysPending[nextKey], function (pendingKey) {\n        childMapping[pendingKey] = getValue(pendingKey, prev, next);\n      });\n    }\n\n    childMapping[nextKey] = getValue(nextKey, prev, next);\n  });\n\n  _forEach(pendingKeys, function (pendingKey) {\n    childMapping[pendingKey] = getValue(pendingKey, prev, next);\n  });\n\n  return childMapping;\n};","map":{"version":3,"sources":["/Users/jason/code/smartcontracts/smart-contracts/devrel/algosigner-react-first/node_modules/semantic-ui-react/dist/es/modules/Transition/utils/childMapping.js"],"names":["_has","_keys","_forEach","_filter","_keyBy","Children","isValidElement","getChildMapping","children","toArray","getPendingKeys","prev","next","nextKeysPending","pendingKeys","prevKey","push","length","getValue","key","mergeChildMappings","childMapping","_getPendingKeys","nextKey","pendingKey"],"mappings":"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","sourcesContent":["import _has from \"lodash-es/has\";\nimport _keys from \"lodash-es/keys\";\nimport _forEach from \"lodash-es/forEach\";\nimport _filter from \"lodash-es/filter\";\nimport _keyBy from \"lodash-es/keyBy\";\nimport { Children, isValidElement } from 'react';\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {object} children Element's children\n * @return {object} Mapping of key to child\n */\n\nexport var getChildMapping = function getChildMapping(children) {\n  return _keyBy(_filter(Children.toArray(children), isValidElement), 'key');\n};\n\nvar getPendingKeys = function getPendingKeys(prev, next) {\n  var nextKeysPending = {};\n  var pendingKeys = [];\n\n  _forEach(_keys(prev), function (prevKey) {\n    if (!_has(next, prevKey)) {\n      pendingKeys.push(prevKey);\n      return;\n    }\n\n    if (pendingKeys.length) {\n      nextKeysPending[prevKey] = pendingKeys;\n      pendingKeys = [];\n    }\n  });\n\n  return [nextKeysPending, pendingKeys];\n};\n\nvar getValue = function getValue(key, prev, next) {\n  return _has(next, key) ? next[key] : prev[key];\n};\n/**\n * When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*\n * since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set\n * of keys and merges them with its best guess of the correct ordering.\n *\n * @param {object} prev Prev children as returned from `getChildMapping()`\n * @param {object} next Next children as returned from `getChildMapping()`\n * @return {object} A key set that contains all keys in `prev` and all keys in `next` in a reasonable order\n */\n\n\nexport var mergeChildMappings = function mergeChildMappings(prev, next) {\n  if (prev === void 0) {\n    prev = {};\n  }\n\n  if (next === void 0) {\n    next = {};\n  }\n\n  var childMapping = {};\n\n  var _getPendingKeys = getPendingKeys(prev, next),\n      nextKeysPending = _getPendingKeys[0],\n      pendingKeys = _getPendingKeys[1];\n\n  _forEach(_keys(next), function (nextKey) {\n    if (_has(nextKeysPending, nextKey)) {\n      _forEach(nextKeysPending[nextKey], function (pendingKey) {\n        childMapping[pendingKey] = getValue(pendingKey, prev, next);\n      });\n    }\n\n    childMapping[nextKey] = getValue(nextKey, prev, next);\n  });\n\n  _forEach(pendingKeys, function (pendingKey) {\n    childMapping[pendingKey] = getValue(pendingKey, prev, next);\n  });\n\n  return childMapping;\n};"]},"metadata":{},"sourceType":"module"}